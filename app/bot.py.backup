import json
_loads = lambda s: json.loads(s) if s else {}
import json
_loads = lambda s: json.loads(s) if s else {}
import os
from typing import Dict, Any


def to_jsonable(obj):
    # recursively convert pydantic models / dataclasses to plain jsonable types
    if hasattr(obj, "model_dump"):
        return obj.model_dump()
    if isinstance(obj, dict):
        return {k: to_jsonable(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [to_jsonable(v) for v in obj]
    return obj

from aiogram import Bot, Dispatcher, F
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder



def cat_title(cat_id: str) -> str:
    for c in CATEGORIES:
        obj = c.model_dump() if hasattr(c, 'model_dump') else c
        if isinstance(obj, dict):
            cid = obj.get('id') or obj.get('code')
            if cid == cat_id:
                return obj.get('title') or obj.get('name') or cat_id
    return cat_id

def risk_title(risk_id: str) -> str:
    for r in RISKS:
        obj = r.model_dump() if hasattr(r, 'model_dump') else r
        if isinstance(obj, dict):
            rid = obj.get('id') or obj.get('code')
            if rid == risk_id:
                return obj.get('title') or obj.get('name') or risk_id
    return risk_id
from .config import get_settings
from .db import (
    connect, init_db, create_deviation, get_deviation, update_deviation,
    get_chosen_variant, set_chosen_variant, get_view_mode, toggle_view_mode
)
from .dicts import load_dict
from .yandex_llm import YandexLLM
from .claude_llm import ClaudeLLM
from .semantic import topk_candidates, load_cached_matrices
from .models import UserInput, LLMResponse
from .prompts import SYSTEM_PROMPT, build_user_prompt, build_regen_prompt
from .exporter import export_docx

SET = get_settings()

con = connect(SET.sqlite_path)
init_db(con)

bot = Bot(token=SET.bot_token)
dp = Dispatcher()

class NewDeviation(StatesGroup):
    full_description = State()

# dictionaries
CATEGORIES = load_dict("./data/deviation_categories.json")
RISKS = load_dict("./data/risks.json")

llm_embeddings = YandexLLM(
    api_key=SET.yc_api_key,
    completion_model_uri=SET.yc_completion_model_uri,
    embedding_model_uri=SET.yc_embedding_model_uri,
    embedding_dim=SET.yc_embedding_dim,
)

llm = ClaudeLLM(api_key=SET.claude_api_key)
CAT_MAT, RISK_MAT = load_cached_matrices()
if CAT_MAT is None or RISK_MAT is None:
    print("[WARN] –Ω–µ—Ç –∫—ç—à–∞ —ç–º–±–µ–¥–¥–∏–Ω–≥–æ–≤. –∑–∞–ø—É—Å—Ç–∏: python -m app.precompute (–æ–¥–∏–Ω —Ä–∞–∑), –ø–æ—Ç–æ–º –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ –±–æ—Ç–∞")
    # fallback: –º–µ–¥–ª–µ–Ω–Ω–æ –ø–æ—Å—á–∏—Ç–∞–µ–º –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ, –Ω–æ –ª—É—á—à–µ –Ω–µ –Ω–∞–¥–æ
    from .semantic import precompute_embeddings
    CAT_MAT = precompute_embeddings(llm_embeddings, CATEGORIES)
    RISK_MAT = precompute_embeddings(llm_embeddings, RISKS)

SECTION_ORDER = [
    "essence",
    "root_causes",
    "business_consequences",
    "cost_calculation",
    "risk_factors",
    "risk_cost_pxI",
    "rsbu_checks",
    "ifrs_checks",
    "measures",
    "opportunities",
]

SECTION_TITLES = {
    "essence": "–æ–ø–∏—Å–∞–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è",
    "root_causes": "–∫–æ—Ä–µ–Ω–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã",
    "business_consequences": "–ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –¥–ª—è –±–∏–∑–Ω–µ—Å–∞",
    "cost_calculation": "—Å—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è",
    "risk_factors": "—Ä–∏—Å–∫-—Ñ–∞–∫—Ç–æ—Ä—ã",
    "risk_cost_pxI": "—Å—Ç–æ–∏–º–æ—Å—Ç—å —Ä–∏—Å–∫–∞ (p√ói)",
    "rsbu_checks": "—Ä—Å–±—É: –ø—Ä–æ–≤–æ–¥–∫–∏ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏",
    "ifrs_checks": "–º—Å—Ñ–æ: –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∏",
    "measures": "–º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏—è",
    "opportunities": "–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è",
    "final_summary": "–∏—Ç–æ–≥–æ–≤–æ–µ —Ä–µ–∑—é–º–µ",
}

def kb_sections(dev_id: int) -> InlineKeyboardBuilder:
    kb = InlineKeyboardBuilder()
    for key in SECTION_ORDER:
        kb.button(text=SECTION_TITLES[key], callback_data=f"sec|{dev_id}|{key}")
    # –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É —Å–∞–º–º–∞—Ä–∏ –≤ –∫–æ–Ω—Ü–µ
    kb.button(text="üìä —Å–∞–º–º–∞—Ä–∏ –¥–ª—è –º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞", callback_data=f"summary|{dev_id}")
    kb.adjust(1)
    return kb

def kb_section_controls(dev_id: int, section_key: str, current_idx: int, mode: str):
    """–∫–Ω–æ–ø–∫–∏: –≤—ã–±–æ—Ä –≤–∞—Ä–∏–∞–Ω—Ç–∞ 1/2/3 + –Ω–∞–∑–∞–¥"""
    kb = InlineKeyboardBuilder()
    
    # –∫–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞
    for i in range(3):
        marker = "‚úì " if i == current_idx else ""
        kb.button(
            text=f"{marker}–≤–∞—Ä–∏–∞–Ω—Ç {i+1}",
            callback_data=f"var|{dev_id}|{section_key}|{i}"
        )
    
    kb.adjust(3)
    
    # –Ω–∞–∑–∞–¥
    kb.button(text="‚Üê –Ω–∞–∑–∞–¥", callback_data=f"back|{dev_id}")
    
    return kb.as_markup()

def render_section(row: Dict[str, Any], section_key: str) -> str:
    sections = _loads(row.get("sections_json"))
    if section_key not in sections:
        return "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —Ä–∞–∑–¥–µ–ª—É (—Å–Ω–∞—á–∞–ª–∞ /build)"
    idx = get_chosen_variant(row, section_key)
    mode = get_view_mode(row, section_key)
    variants = sections[section_key].get("variants", [])
    if not variants:
        return "–Ω–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤"
    idx = max(0, min(idx, len(variants)-1))
    text = variants[idx] if isinstance(variants[idx], str) else str(variants[idx])
    # escape markdown special chars to avoid telegram parse errors
    # but keep ** for bold
    text = text.replace('_', '\\_').replace('[', '\\[').replace(']', '\\]').replace('(', '\\(').replace(')', '\\)')
    title = SECTION_TITLES.get(section_key, section_key)
    return f"**{title}**\n\n{text}"

@dp.message(Command("start"))
async def start(m: Message):
    await m.answer(
        "–æ–∫. –∫–æ–º–∞–Ω–¥—ã:\n"
        "/new ‚Äî –Ω–æ–≤–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞\n"
        "/build <id> ‚Äî —Å–≥–µ–Ω–µ—Ä–∏—Ç—å –æ—Ç—á—ë—Ç\n"
        "/preview <id> ‚Äî –º–µ–Ω—é —Ä–∞–∑–¥–µ–ª–æ–≤\n"
        "/export <id> ‚Äî –≤—ã–≥—Ä—É–∑–∫–∞ docx"
    )

@dp.message(Command("new"))
async def new(m: Message, state: FSMContext):
    await state.set_state(NewDeviation.full_description)
    await m.answer(
        "–û–ø–∏—à–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–æ —à–∞–±–ª–æ–Ω—É (–µ—Å–ª–∏ —á–µ–≥–æ-—Ç–æ –Ω–µ –∑–Ω–∞–µ—à—å ‚Äì –Ω–æ—Ä–º–∞–ª—å–Ω–æ, —è –ø–æ–¥—Å—Ç–∞–≤–ª—é —Ç–∏–ø–æ–≤—ã–µ –ø—Ä–∏–º–µ—Ä—ã –∏–∑ –ø—Ä–∞–∫—Ç–∏–∫–∏):\n\n"
        "1Ô∏è‚É£ –ß–¢–û –Ω–∞—Ä—É—à–µ–Ω–æ? (–∫–∞–∫–∞—è –Ω–æ—Ä–º–∞/–¥–æ–≥–æ–≤–æ—Ä/–ª–Ω–∞)\n"
        "2Ô∏è‚É£ –ì–î–ï? (–ø–æ–¥—Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ/–ø—Ä–æ—Ü–µ—Å—Å)\n"
        "3Ô∏è‚É£ –ö–û–ì–î–ê? (–¥–∞—Ç–∞/–ø–µ—Ä–∏–æ–¥)\n"
        "4Ô∏è‚É£ –ü–û–ß–ï–ú–£? (–ø—Ä–∏—á–∏–Ω–∞)\n"
        "5Ô∏è‚É£ –ö–¢–û? (—Ñ–∏–æ + –¥–æ–ª–∂–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ)\n\n"
        "–ü—Ä–∏–º–µ—Ä:\n"
        "\"–ù–∞—Ä—É—à–µ–Ω –ø.2.3 –î–æ–≥–æ–≤–æ—Ä–∞ ‚Ññ456 –æ—Ç 01.09.2024: –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∞ –æ–ø–ª–∞—Ç–∞ –±–µ–∑ –∞–∫—Ç–∞ –ø—Ä–∏—ë–º–∫–∏ "
        "–≤ –æ—Ç–¥–µ–ª–µ —Å–Ω–∞–±–∂–µ–Ω–∏—è 15.12.2024 –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –∫–æ–Ω—Ç—Ä–æ–ª—è. "
        "–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π: –ò–≤–∞–Ω–æ–≤ –ò.–ò., –Ω–∞—á.–æ—Ç–¥–µ–ª–∞ —Å–Ω–∞–±–∂–µ–Ω–∏—è\"\n\n"
        "–ú–æ–∂–µ—à—å –ø–∏—Å–∞—Ç—å —Å–≤–æ–±–æ–¥–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º ‚Äì –≥–ª–∞–≤–Ω–æ–µ —á—Ç–æ–±—ã —ç—Ç–∏ 5 –ø—É–Ω–∫—Ç–æ–≤ –±—ã–ª–∏ –ø–æ–Ω—è—Ç–Ω—ã."
    )

@dp.message(NewDeviation.full_description)
async def handle_full_description(m: Message, state: FSMContext):
    description = m.text.strip()
    
    # —Å–æ–∑–¥–∞—ë–º user_input —Å –µ–¥–∏–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º
    ui = UserInput(
        problem_text=description,
        process_object="",
        period="",
        participants_roles="",
        what_violated="",
        amounts_terms="",
        documents=""
    ).model_dump()
    
    dev_id = create_deviation(con, telegram_user_id=m.from_user.id, user_input=ui)
    await state.clear()
    await m.answer(f"–ß–µ—Ä–Ω–æ–≤–∏–∫ —Å–æ–∑–¥–∞–Ω: id={dev_id}\n/build {dev_id} ‚Äî —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—á—ë—Ç")

@dp.message(Command("build"))
async def build(m: Message):
    parts = m.text.split()
    if len(parts) < 2:
        await m.answer("–∏—Å–ø–æ–ª—å–∑—É–π: /build <id>")
        return
    dev_id = int(parts[1])
    row = get_deviation(con, dev_id)
    ui = json.loads(row["user_input_json"])
    ui_obj = UserInput(**ui)

    await m.answer(
        "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ –≤ –ª–æ–≥–∏–∫–µ –ø—Ä–∏—á–∏–Ω–Ω–æ-—Å–ª–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ–π —Å–≤—è–∑–∏ –∏ –≤–ª–∏—è–Ω–∏—è –Ω–∞ –±–∏–∑–Ω–µ—Å "
        "(powered by Claude Anthropic AI Sonnet 4.5). –≠—Ç–æ –∑–∞–π–º—ë—Ç 3-4 –º–∏–Ω—É—Ç—ã."
    )

    candidates = topk_candidates(llm_embeddings, ui_obj, CATEGORIES, RISKS, CAT_MAT, RISK_MAT, k=20)

    messages = [
        {"role": "system", "text": SYSTEM_PROMPT},
        {"role": "user", "text": build_user_prompt(ui, candidates)},
    ]
    raw = llm.completion(messages, temperature=0.2, max_tokens=16000)

    # --- clean model output (remove ```json fences etc.) ---
    clean = raw.strip()
    if clean.startswith("```"):
        clean = clean.split("\n", 1)[1] if "\n" in clean else ""
        if "```" in clean:
            clean = clean.rsplit("```", 1)[0]
    clean = clean.strip()
    
    # fix control characters in json strings
    import re
    clean = re.sub(r'[\x00-\x1f\x7f-\x9f]', ' ', clean)
    # ------------------------------------------------------

    try:
        data = json.loads(clean)
        parsed = LLMResponse(**data)
    except Exception as e:
        await m.answer(f"gpt –≤–µ—Ä–Ω—É–ª –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π json. –æ—à–∏–±–∫–∞: {e}\n—Å—ã—Ä–µ—Ü (–ø–µ—Ä–≤—ã–µ 1200 —Å–∏–º–≤–æ–ª–æ–≤):\n{raw[:1200]}")
        return

    sections_dump = {k: v.model_dump() for k, v in parsed.sections.items()}
    update_deviation(con, dev_id, selected=to_jsonable(parsed.selected), sections=sections_dump)
    await m.answer(f"–ì–æ—Ç–æ–≤–æ!\n/preview {dev_id} ‚Äî –ø—Ä–æ—Å–º–æ—Ç—Ä –∏ –≤—ã–±–æ—Ä –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Ä–∞–∑–¥–µ–ª–æ–≤")

@dp.message(Command("preview"))
async def preview(m: Message):
    parts = m.text.split()
    if len(parts) < 2:
        await m.answer("–∏—Å–ø–æ–ª—å–∑—É–π: /preview <id>")
        return
    dev_id = int(parts[1])
    row = get_deviation(con, dev_id)
    if not row.get("sections_json"):
        await m.answer("–Ω–µ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. —Å–Ω–∞—á–∞–ª–∞ /build")
        return

    selected = _loads(row.get("selected_json"))
    txt = "–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ä–∞–∑–¥–µ–ª–æ–≤. –í—ã–±—Ä–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç (‚úì) –ø–æ–ø–∞–¥—ë—Ç –≤ –∏—Ç–æ–≥–æ–≤–æ–µ —Ä–µ–∑—é–º–µ:"
    await m.answer(txt, reply_markup=kb_sections(dev_id).as_markup())

@dp.message(Command("export"))
async def export_cmd(m: Message):
    parts = m.text.split()
    if len(parts) < 2:
        await m.answer("–∏—Å–ø–æ–ª—å–∑—É–π: /export <id>")
        return
    dev_id = int(parts[1])
    row = get_deviation(con, dev_id)
    if not row.get("sections_json"):
        await m.answer("–Ω–µ—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. —Å–Ω–∞—á–∞–ª–∞ /build")
        return

    user_input = _loads(row.get("user_input_json"))
    selected = _loads(row.get("selected_json"))
    sections = _loads(row.get("sections_json"))
    chosen = _loads(row.get("chosen_variants_json"))
    view_mode = _loads(row.get("view_mode_json"))

    out_path = f"./exports/deviation_{dev_id}.docx"
    p = export_docx(out_path, dev_id, user_input, selected, sections, chosen, view_mode)
    await m.answer_document(open(p, "rb"), caption=f"docx —ç–∫—Å–ø–æ—Ä—Ç: deviation_{dev_id}.docx")

@dp.callback_query(F.data.startswith("back|"))
async def cb_back(q: CallbackQuery):
    _, dev_id = q.data.split("|", 1)
    dev_id = int(dev_id)
    row = get_deviation(con, dev_id)
    selected = _loads(row.get("selected_json"))
    txt = (
        f"**id {dev_id}**\n"
        f"–∫–∞—Ç–µ–≥–æ—Ä–∏—è: {cat_title(selected.get('deviation_category',{}).get('primary_id',''))}\n"
        f"—Ä–∏—Å–∫: {risk_title(selected.get('risk',{}).get('primary_id',''))}\n\n"
        "–≤—ã–±–µ—Ä–∏ —Ä–∞–∑–¥–µ–ª:"
    )
    await q.message.edit_text(txt, reply_markup=kb_sections(dev_id).as_markup(), parse_mode="Markdown")
    await q.answer()

@dp.callback_query(F.data.startswith("sec|"))
async def cb_section(q: CallbackQuery):
    _, dev_id, section_key = q.data.split("|", 2)
    dev_id = int(dev_id)
    row = get_deviation(con, dev_id)
    idx = get_chosen_variant(row, section_key)
    mode = get_view_mode(row, section_key)
    txt = render_section(row, section_key)
    await q.message.edit_text(txt, reply_markup=kb_section_controls(dev_id, section_key, idx, mode), parse_mode="Markdown")
    await q.answer()

@dp.callback_query(F.data.startswith("var|"))
async def cb_var(q: CallbackQuery):
    _, dev_id, section_key, idx = q.data.split("|", 3)
    dev_id = int(dev_id)
    idx = int(idx)
    row = get_deviation(con, dev_id)
    set_chosen_variant(con, dev_id, row, section_key, idx)
    row = get_deviation(con, dev_id)
    mode = get_view_mode(row, section_key)
    txt = render_section(row, section_key)
    await q.message.edit_text(txt, reply_markup=kb_section_controls(dev_id, section_key, idx, mode), parse_mode="Markdown")
    await q.answer("–æ–∫")

@dp.callback_query(F.data.startswith("mode|"))
async def cb_mode(q: CallbackQuery):
    _, dev_id, section_key = q.data.split("|", 2)
    dev_id = int(dev_id)
    row = get_deviation(con, dev_id)
    toggle_view_mode(con, dev_id, row, section_key)
    row = get_deviation(con, dev_id)
    idx = get_chosen_variant(row, section_key)
    mode = get_view_mode(row, section_key)
    txt = render_section(row, section_key)
    await q.message.edit_text(txt, reply_markup=kb_section_controls(dev_id, section_key, idx, mode), parse_mode="Markdown")
    await q.answer("–ø–µ—Ä–µ–∫–ª—é—á–∏–ª")

@dp.callback_query(F.data.startswith("regen|"))
async def cb_regen(q: CallbackQuery):
    _, dev_id, section_key = q.data.split("|", 2)
    dev_id = int(dev_id)
    row = get_deviation(con, dev_id)
    if not row.get("sections_json"):
        await q.answer("—Å–Ω–∞—á–∞–ª–∞ /build", show_alert=True)
        return

    ui = _loads(row.get("user_input_json"))
    selected = _loads(row.get("selected_json"))
    sections = _loads(row.get("sections_json"))

    # candidates for context (same as build)
    ui_obj = UserInput(**ui)
    candidates = topk_candidates(llm_embeddings, ui_obj, CATEGORIES, RISKS, CAT_MAT, RISK_MAT, k=20)

    await q.answer("regen‚Ä¶", show_alert=False)

    messages = [
        {"role": "system", "text": SYSTEM_PROMPT},
        {"role": "user", "text": build_regen_prompt(ui, selected, section_key, old_variants, candidates)},
    ]
    raw = llm.completion(messages, temperature=0.25, max_tokens=16000)

    # --- clean regen output ---
    clean_regen = raw.strip()
    if clean_regen.startswith("```"):
        clean_regen = clean_regen.split("\n", 1)[1] if "\n" in clean_regen else ""
        if "```" in clean_regen:
            clean_regen = clean_regen.rsplit("```", 1)[0]
    clean_regen = clean_regen.strip()
    # --------------------------

    try:
        data = json.loads(clean_regen)
        if data.get("section_key") != section_key:
            raise ValueError("section_key mismatch")
        new_variants = data["variants"]
        # basic shape validation + pad/cut to 5 variants
        if not isinstance(new_variants, list):
            raise ValueError("variants must be list")

        if len(new_variants) < 3:
            raise ValueError("variants must be list of 3..5")

        # pad to 5 if model returned only 3-4
        while len(new_variants) < 5:
            base = new_variants[-1] if new_variants else {"short": "", "full": ""}
            short = (base.get("short") or "").strip()
            full = (base.get("full") or "").strip()
            new_variants.append({
                "short": (short + " (–≤–∞—Ä–∏–∞–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)") if short else "–≤–∞—Ä–∏–∞–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏",
                "full": (full + "\\n\\n(–≤–∞—Ä–∏–∞–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏: –º–æ–¥–µ–ª—å –≤–µ—Ä–Ω—É–ª–∞ –º–µ–Ω—å—à–µ 5)") if full else "(–≤–∞—Ä–∏–∞–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏: –º–æ–¥–µ–ª—å –≤–µ—Ä–Ω—É–ª–∞ –º–µ–Ω—å—à–µ 5)"
            })

        # cut to 5 if model returned more
        if len(new_variants) > 5:
            new_variants = new_variants[:5]

        sections[section_key] = {"variants": new_variants}
        update_deviation(con, dev_id, sections=sections)
    except Exception as e:
        await q.message.answer(f"regen —É–ø–∞–ª: {e}\n—Å—ã—Ä–µ—Ü (–¥–æ 900):\n{raw[:900]}")
        return

    row = get_deviation(con, dev_id)
    idx = get_chosen_variant(row, section_key)
    mode = get_view_mode(row, section_key)
    txt = render_section(row, section_key)
    await q.message.edit_text(txt, reply_markup=kb_section_controls(dev_id, section_key, idx, mode), parse_mode="Markdown")
    await q.answer("–≥–æ—Ç–æ–≤–æ")

@dp.callback_query(F.data.startswith("summary|"))
async def cb_summary(q: CallbackQuery):
    _, dev_id = q.data.split("|", 1)
    dev_id = int(dev_id)
    row = get_deviation(con, dev_id)
    
    if not row.get("sections_json"):
        await q.answer("–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö. —Å–Ω–∞—á–∞–ª–∞ /build", show_alert=True)
        return
    
    sections_data = json.loads(row["sections_json"])
    
    if "final_summary" not in sections_data:
        await q.answer("—Å–∞–º–º–∞—Ä–∏ –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ", show_alert=True)
        return
    
    summary_text = sections_data["final_summary"].get("variants", [""])[0]
    
    # —Ä–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —á–∞—Å—Ç–∏ –µ—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (telegram limit 4096)
    if len(summary_text) > 4000:
        parts = [summary_text[i:i+4000] for i in range(0, len(summary_text), 4000)]
        await q.message.answer(f"**–ò–¢–û–ì–û–í–û–ï –†–ï–ó–Æ–ú–ï (—á–∞—Å—Ç—å 1/{len(parts)}):**\n\n{parts[0]}")
        for idx, part in enumerate(parts[1:], start=2):
            await q.message.answer(f"**(—á–∞—Å—Ç—å {idx}/{len(parts)}):**\n\n{part}")
    else:
        await q.message.answer(f"**–ò–¢–û–ì–û–í–û–ï –†–ï–ó–Æ–ú–ï:**\n\n{summary_text}")
    
    await q.message.answer(f"/export {dev_id} ‚Äî –≤—ã–≥—Ä—É–∑–∏—Ç—å –≤ docx")
    await q.answer("–≥–æ—Ç–æ–≤–æ")

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
